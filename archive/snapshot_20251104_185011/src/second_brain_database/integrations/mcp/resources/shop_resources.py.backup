"""
Shop and Asset MCP Resources

Comprehensive information resources for shop catalog, user assets,
and financial information through MCP resources.
"""

import json
from typing import Dict, Any, List, Optional
from datetime import datetime

from ....managers.logging_manager import get_logger
from ....config import settings
from ..modern_server import mcp
from ..security import get_mcp_user_context
from ..context import create_mcp_audit_trail
from ..exceptions import MCPAuthorizationError, MCPValidationError

logger = get_logger(prefix="[MCP_ShopResources]")

# Import manager instances
from ....database import db_manager
from ....managers.security_manager import security_manager
from ....managers.redis_manager import redis_manager

@mcp.resource("shop://catalog", tags={"production", "resources", "secure", "shop"})
    async def get_shop_catalog_resource() -> str:
        """
        Get comprehensive shop catalog as a resource for item browsing.
        
        Provides complete shop catalog with items, categories, and pricing
        information available to all authenticated users.
        
        Returns:
            JSON string containing shop catalog
        """
        try:
            user_context = get_mcp_user_context()
            
            # Get shop collections
            shop_items_collection = db_manager.get_collection("shop_items")
            categories_collection = db_manager.get_collection("shop_categories")
            
            # Get all available shop items
            shop_items = await shop_items_collection.find({
                "available": True,
                "deleted": {"$ne": True}
            }).to_list(length=None)
            
            # Get categories
            categories = await categories_collection.find({
                "active": True
            }).to_list(length=None)
            
            # Create audit trail
            await create_mcp_audit_trail(
                operation="get_shop_catalog_resource",
                user_context=user_context,
                resource_type="shop",
                resource_id="catalog",
                metadata={"resource_type": "shop_catalog", "item_count": len(shop_items)}
            )
            
            # Format catalog information
            catalog = {
                "categories": [
                    {
                        "id": str(cat.get("_id")),
                        "name": cat.get("name"),
                        "description": cat.get("description"),
                        "item_count": len([item for item in shop_items if item.get("category_id") == str(cat.get("_id"))])
                    }
                    for cat in categories
                ],
                "items": [
                    {
                        "id": str(item.get("_id")),
                        "name": item.get("name"),
                        "description": item.get("description"),
                        "category_id": item.get("category_id"),
                        "type": item.get("type"),  # avatar, banner, theme
                        "price": item.get("price", 0),
                        "rental_price": item.get("rental_price"),
                        "rental_duration_days": item.get("rental_duration_days"),
                        "preview_url": item.get("preview_url"),
                        "tags": item.get("tags", []),
                        "featured": item.get("featured", False),
                        "new_arrival": item.get("new_arrival", False),
                        "created_at": item.get("created_at").isoformat() if item.get("created_at") else None
                    }
                    for item in shop_items
                ],
                "statistics": {
                    "total_items": len(shop_items),
                    "total_categories": len(categories),
                    "featured_items": len([item for item in shop_items if item.get("featured")]),
                    "new_arrivals": len([item for item in shop_items if item.get("new_arrival")])
                },
                "last_updated": datetime.utcnow().isoformat()
            }
            
            logger.info("Provided shop catalog resource to user %s (%d items)", 
                       user_context.user_id, len(shop_items))
            
            return json.dumps(catalog, indent=2, default=str)
            
        except Exception as e:
            logger.error("Failed to get shop catalog resource: %s", e)
            return json.dumps({"error": f"Failed to retrieve shop catalog: {str(e)}"}, indent=2)


        @mcp.resource("user://{user_id}/assets", tags={"production", "resources", "secure", "shop"})
    async def get_user_assets_resource(user_id: str) -> str:
        """
        Get user's owned and rented assets as a resource.
        
        Provides comprehensive asset information including owned items,
        active rentals, and usage history. Only accessible by the user themselves.
        
        Args:
            user_id: The ID of the user to get assets for
            
        Returns:
            JSON string containing user assets
        """
        try:
            user_context = get_mcp_user_context()
            
            # Default to current user if user_id is "me"
            target_user_id = user_id if user_id != "me" else user_context.user_id
            
            # Only allow access to own assets
            if target_user_id != user_context.user_id:
                return json.dumps({"error": "Access denied - can only view own assets"}, indent=2)
            
            # Get collections
            user_assets_collection = db_manager.get_collection("user_assets")
            shop_items_collection = db_manager.get_collection("shop_items")
            
            # Get user's assets
            user_assets = await user_assets_collection.find({
                "user_id": target_user_id,
                "deleted": {"$ne": True}
            }).to_list(length=None)
            
            # Get shop item details for assets
            asset_item_ids = [asset.get("item_id") for asset in user_assets if asset.get("item_id")]
            shop_items = await shop_items_collection.find({
                "_id": {"$in": asset_item_ids}
            }).to_list(length=None)
            
            # Create lookup for shop items
            shop_items_lookup = {str(item.get("_id")): item for item in shop_items}
            
            # Create audit trail
            await create_mcp_audit_trail(
                operation="get_user_assets_resource",
                user_context=user_context,
                resource_type="user",
                resource_id=target_user_id,
                metadata={"resource_type": "user_assets", "asset_count": len(user_assets)}
            )
            
            # Categorize assets
            owned_assets = []
            rented_assets = []
            expired_rentals = []
            
            now = datetime.utcnow()
            
            for asset in user_assets:
                item_info = shop_items_lookup.get(asset.get("item_id"), {})
                
                asset_info = {
                    "id": str(asset.get("_id")),
                    "item_id": asset.get("item_id"),
                    "item_name": item_info.get("name"),
                    "item_type": item_info.get("type"),
                    "acquisition_type": asset.get("acquisition_type"),  # purchase, rental
                    "acquired_at": asset.get("acquired_at").isoformat() if asset.get("acquired_at") else None,
                    "price_paid": asset.get("price_paid", 0),
                    "preview_url": item_info.get("preview_url"),
                    "currently_active": asset.get("currently_active", False)
                }
                
                if asset.get("acquisition_type") == "purchase":
                    owned_assets.append(asset_info)
                elif asset.get("acquisition_type") == "rental":
                    rental_expires = asset.get("rental_expires_at")
                    asset_info["rental_expires_at"] = rental_expires.isoformat() if rental_expires else None
                    asset_info["days_remaining"] = (rental_expires - now).days if rental_expires and rental_expires > now else 0
                    
                    if rental_expires and rental_expires > now:
                        rented_assets.append(asset_info)
                    else:
                        expired_rentals.append(asset_info)
            
            # Compile asset information
            assets = {
                "user_id": target_user_id,
                "owned_assets": {
                    "total": len(owned_assets),
                    "by_type": {
                        "avatars": len([a for a in owned_assets if a.get("item_type") == "avatar"]),
                        "banners": len([a for a in owned_assets if a.get("item_type") == "banner"]),
                        "themes": len([a for a in owned_assets if a.get("item_type") == "theme"])
                    },
                    "items": owned_assets
                },
                "rented_assets": {
                    "total": len(rented_assets),
                    "by_type": {
                        "avatars": len([a for a in rented_assets if a.get("item_type") == "avatar"]),
                        "banners": len([a for a in rented_assets if a.get("item_type") == "banner"]),
                        "themes": len([a for a in rented_assets if a.get("item_type") == "theme"])
                    },
                    "items": rented_assets
                },
                "expired_rentals": {
                    "total": len(expired_rentals),
                    "items": expired_rentals
                },
                "currently_active": {
                    "avatar": next((a for a in user_assets if a.get("item_type") == "avatar" and a.get("currently_active")), None),
                    "banner": next((a for a in user_assets if a.get("item_type") == "banner" and a.get("currently_active")), None),
                    "theme": next((a for a in user_assets if a.get("item_type") == "theme" and a.get("currently_active")), None)
                },
                "last_updated": datetime.utcnow().isoformat()
            }
            
            logger.info("Provided user assets resource for user %s (%d total assets)", 
                       target_user_id, len(user_assets))
            
            return json.dumps(assets, indent=2, default=str)
            
        except Exception as e:
            logger.error("Failed to get user assets resource for %s: %s", user_id, e)
            return json.dumps({"error": f"Failed to retrieve user assets: {str(e)}"}, indent=2)


        @mcp.resource("user://{user_id}/transactions", tags={"production", "resources", "secure", "shop"})
    async def get_transaction_history_resource(user_id: str) -> str:
        """
        Get user's transaction history as a resource for purchase records.
        
        Provides comprehensive transaction history including purchases,
        rentals, and SBD token transactions. Only accessible by the user themselves.
        
        Args:
            user_id: The ID of the user to get transaction history for
            
        Returns:
            JSON string containing transaction history
        """
        try:
            user_context = get_mcp_user_context()
            
            # Default to current user if user_id is "me"
            target_user_id = user_id if user_id != "me" else user_context.user_id
            
            # Only allow access to own transaction history
            if target_user_id != user_context.user_id:
                return json.dumps({"error": "Access denied - can only view own transaction history"}, indent=2)
            
            # Get collections
            transactions_collection = db_manager.get_collection("transactions")
            shop_items_collection = db_manager.get_collection("shop_items")
            
            # Get user's transactions
            transactions = await transactions_collection.find({
                "user_id": target_user_id,
                "deleted": {"$ne": True}
            }).sort("created_at", -1).to_list(length=100)  # Last 100 transactions
            
            # Get shop item details for transactions
            transaction_item_ids = [t.get("item_id") for t in transactions if t.get("item_id")]
            shop_items = await shop_items_collection.find({
                "_id": {"$in": transaction_item_ids}
            }).to_list(length=None)
            
            # Create lookup for shop items
            shop_items_lookup = {str(item.get("_id")): item for item in shop_items}
            
            # Create audit trail
            await create_mcp_audit_trail(
                operation="get_transaction_history_resource",
                user_context=user_context,
                resource_type="user",
                resource_id=target_user_id,
                metadata={"resource_type": "transaction_history", "transaction_count": len(transactions)}
            )
            
            # Format transaction history
            transaction_history = []
            total_spent = 0
            
            for transaction in transactions:
                item_info = shop_items_lookup.get(transaction.get("item_id"), {})
                
                transaction_info = {
                    "id": str(transaction.get("_id")),
                    "type": transaction.get("type"),  # purchase, rental, sbd_transfer, etc.
                    "amount": transaction.get("amount", 0),
                    "currency": transaction.get("currency", "SBD"),
                    "status": transaction.get("status"),
                    "created_at": transaction.get("created_at").isoformat() if transaction.get("created_at") else None,
                    "description": transaction.get("description"),
                    "item": {
                        "id": transaction.get("item_id"),
                        "name": item_info.get("name"),
                        "type": item_info.get("type")
                    } if transaction.get("item_id") else None,
                    "metadata": transaction.get("metadata", {})
                }
                
                transaction_history.append(transaction_info)
                
                if transaction.get("type") in ["purchase", "rental"] and transaction.get("status") == "completed":
                    total_spent += transaction.get("amount", 0)
            
            # Calculate statistics
            purchase_count = len([t for t in transactions if t.get("type") == "purchase"])
            rental_count = len([t for t in transactions if t.get("type") == "rental"])
            sbd_transactions = len([t for t in transactions if t.get("type") in ["sbd_transfer", "sbd_request"]])
            
            result = {
                "user_id": target_user_id,
                "transactions": transaction_history,
                "statistics": {
                    "total_transactions": len(transactions),
                    "total_spent": total_spent,
                    "purchase_count": purchase_count,
                    "rental_count": rental_count,
                    "sbd_transactions": sbd_transactions,
                    "average_transaction": total_spent / len(transactions) if transactions else 0
                },
                "last_updated": datetime.utcnow().isoformat()
            }
            
            logger.info("Provided transaction history resource for user %s (%d transactions)", 
                       target_user_id, len(transactions))
            
            return json.dumps(result, indent=2, default=str)
            
        except Exception as e:
            logger.error("Failed to get transaction history resource for %s: %s", user_id, e)
            return json.dumps({"error": f"Failed to retrieve transaction history: {str(e)}"}, indent=2)


        @mcp.resource("user://{user_id}/sbd/balance", tags={"production", "resources", "secure", "shop"})
    async def get_sbd_balance_resource(user_id: str) -> str:
        """
        Get user's SBD token balance and information as a resource.
        
        Provides current SBD balance, earning history, and spending analytics.
        Only accessible by the user themselves for privacy.
        
        Args:
            user_id: The ID of the user to get SBD balance for
            
        Returns:
            JSON string containing SBD balance information
        """
        try:
            user_context = get_mcp_user_context()
            
            # Default to current user if user_id is "me"
            target_user_id = user_id if user_id != "me" else user_context.user_id
            
            # Only allow access to own SBD balance
            if target_user_id != user_context.user_id:
                return json.dumps({"error": "Access denied - can only view own SBD balance"}, indent=2)
            
            # Get collections
            users_collection = db_manager.get_collection("users")
            sbd_transactions_collection = db_manager.get_collection("sbd_transactions")
            
            # Get user's SBD information
            user_data = await users_collection.find_one(
                {"_id": target_user_id},
                {"sbd_balance": 1, "sbd_stats": 1}
            )
            
            if not user_data:
                return json.dumps({"error": "User not found"}, indent=2)
            
            # Get recent SBD transactions
            recent_transactions = await sbd_transactions_collection.find({
                "user_id": target_user_id,
                "deleted": {"$ne": True}
            }).sort("created_at", -1).limit(20).to_list(length=None)
            
            # Create audit trail
            await create_mcp_audit_trail(
                operation="get_sbd_balance_resource",
                user_context=user_context,
                resource_type="user",
                resource_id=target_user_id,
                metadata={"resource_type": "sbd_balance"}
            )
            
            # Format SBD balance information
            sbd_info = {
                "user_id": target_user_id,
                "current_balance": user_data.get("sbd_balance", 0),
                "statistics": {
                    "total_earned": user_data.get("sbd_stats", {}).get("total_earned", 0),
                    "total_spent": user_data.get("sbd_stats", {}).get("total_spent", 0),
                    "transaction_count": user_data.get("sbd_stats", {}).get("transaction_count", 0),
                    "average_transaction": user_data.get("sbd_stats", {}).get("average_transaction", 0),
                    "largest_transaction": user_data.get("sbd_stats", {}).get("largest_transaction", 0)
                },
                "recent_transactions": [
                    {
                        "id": str(transaction.get("_id")),
                        "type": transaction.get("type"),
                        "amount": transaction.get("amount"),
                        "description": transaction.get("description"),
                        "created_at": transaction.get("created_at").isoformat() if transaction.get("created_at") else None,
                        "status": transaction.get("status")
                    }
                    for transaction in recent_transactions
                ],
                "last_updated": datetime.utcnow().isoformat()
            }
            
            logger.info("Provided SBD balance resource for user %s (balance: %d)", 
                       target_user_id, user_data.get("sbd_balance", 0))
            
            return json.dumps(sbd_info, indent=2, default=str)
            
        except Exception as e:
            logger.error("Failed to get SBD balance resource for %s: %s", user_id, e)
            return json.dumps({"error": f"Failed to retrieve SBD balance: {str(e)}"}, indent=2)


        @mcp.resource("user://{user_id}/spending/analytics", tags={"production", "resources", "secure", "shop"})
    async def get_spending_analytics_resource(user_id: str) -> str:
        """
        Get user's spending analytics as a resource for financial insights.
        
        Provides comprehensive spending analysis including category breakdowns,
        trends, and recommendations. Only accessible by the user themselves.
        
        Args:
            user_id: The ID of the user to get spending analytics for
            
        Returns:
            JSON string containing spending analytics
        """
        try:
            user_context = get_mcp_user_context()
            
            # Default to current user if user_id is "me"
            target_user_id = user_id if user_id != "me" else user_context.user_id
            
            # Only allow access to own spending analytics
            if target_user_id != user_context.user_id:
                return json.dumps({"error": "Access denied - can only view own spending analytics"}, indent=2)
            
            # Get collections
            transactions_collection = db_manager.get_collection("transactions")
            shop_items_collection = db_manager.get_collection("shop_items")
            
            # Get user's spending transactions (last 90 days)
            ninety_days_ago = datetime.utcnow() - datetime.timedelta(days=90)
            spending_transactions = await transactions_collection.find({
                "user_id": target_user_id,
                "type": {"$in": ["purchase", "rental"]},
                "status": "completed",
                "created_at": {"$gte": ninety_days_ago},
                "deleted": {"$ne": True}
            }).to_list(length=None)
            
            # Get shop item details
            transaction_item_ids = [t.get("item_id") for t in spending_transactions if t.get("item_id")]
            shop_items = await shop_items_collection.find({
                "_id": {"$in": transaction_item_ids}
            }).to_list(length=None)
            
            # Create lookup for shop items
            shop_items_lookup = {str(item.get("_id")): item for item in shop_items}
            
            # Create audit trail
            await create_mcp_audit_trail(
                operation="get_spending_analytics_resource",
                user_context=user_context,
                resource_type="user",
                resource_id=target_user_id,
                metadata={"resource_type": "spending_analytics", "transaction_count": len(spending_transactions)}
            )
            
            # Analyze spending patterns
            total_spent = sum(t.get("amount", 0) for t in spending_transactions)
            
            # Category breakdown
            category_spending = {}
            type_spending = {"avatar": 0, "banner": 0, "theme": 0}
            monthly_spending = {}
            
            for transaction in spending_transactions:
                amount = transaction.get("amount", 0)
                item_info = shop_items_lookup.get(transaction.get("item_id"), {})
                item_type = item_info.get("type", "unknown")
                
                # Type spending
                if item_type in type_spending:
                    type_spending[item_type] += amount
                
                # Monthly spending
                month_key = transaction.get("created_at").strftime("%Y-%m") if transaction.get("created_at") else "unknown"
                monthly_spending[month_key] = monthly_spending.get(month_key, 0) + amount
            
            # Calculate trends and insights
            avg_transaction = total_spent / len(spending_transactions) if spending_transactions else 0
            most_expensive = max(spending_transactions, key=lambda t: t.get("amount", 0)) if spending_transactions else None
            
            analytics = {
                "user_id": target_user_id,
                "period": "last_90_days",
                "summary": {
                    "total_spent": total_spent,
                    "transaction_count": len(spending_transactions),
                    "average_transaction": avg_transaction,
                    "most_expensive_transaction": most_expensive.get("amount", 0) if most_expensive else 0
                },
                "spending_by_type": type_spending,
                "monthly_spending": monthly_spending,
                "insights": {
                    "most_purchased_type": max(type_spending.items(), key=lambda x: x[1])[0] if type_spending else None,
                    "spending_trend": "increasing" if len(monthly_spending) > 1 and list(monthly_spending.values())[-1] > list(monthly_spending.values())[0] else "stable",
                    "average_monthly_spend": sum(monthly_spending.values()) / len(monthly_spending) if monthly_spending else 0
                },
                "recommendations": [
                    "Consider renting items before purchasing to save SBD tokens",
                    "Look for featured items which often have better value",
                    "Set a monthly spending budget to track expenses"
                ],
                "generated_at": datetime.utcnow().isoformat()
            }
            
            logger.info("Provided spending analytics resource for user %s (total spent: %d)", 
                       target_user_id, total_spent)
            
            return json.dumps(analytics, indent=2, default=str)
            
        except Exception as e:
            logger.error("Failed to get spending analytics resource for %s: %s", user_id, e)
            return json.dumps({"error": f"Failed to retrieve spending analytics: {str(e)}"}, indent=2)


        @mcp.resource("user://{user_id}/assets/usage", tags={"production", "resources", "secure", "shop"})
    async def get_asset_usage_resource(user_id: str) -> str:
        """
        Get user's asset usage tracking as a resource.
        
        Provides comprehensive asset usage statistics including activation
        history, preferences, and optimization recommendations.
        
        Args:
            user_id: The ID of the user to get asset usage for
            
        Returns:
            JSON string containing asset usage tracking
        """
        try:
            user_context = get_mcp_user_context()
            
            # Default to current user if user_id is "me"
            target_user_id = user_id if user_id != "me" else user_context.user_id
            
            # Only allow access to own asset usage
            if target_user_id != user_context.user_id:
                return json.dumps({"error": "Access denied - can only view own asset usage"}, indent=2)
            
            # Get collections
            asset_usage_collection = db_manager.get_collection("asset_usage_history")
            user_assets_collection = db_manager.get_collection("user_assets")
            
            # Get asset usage history (last 30 days)
            thirty_days_ago = datetime.utcnow() - datetime.timedelta(days=30)
            usage_history = await asset_usage_collection.find({
                "user_id": target_user_id,
                "created_at": {"$gte": thirty_days_ago}
            }).sort("created_at", -1).to_list(length=None)
            
            # Get current assets
            current_assets = await user_assets_collection.find({
                "user_id": target_user_id,
                "deleted": {"$ne": True}
            }).to_list(length=None)
            
            # Create audit trail
            await create_mcp_audit_trail(
                operation="get_asset_usage_resource",
                user_context=user_context,
                resource_type="user",
                resource_id=target_user_id,
                metadata={"resource_type": "asset_usage", "usage_records": len(usage_history)}
            )
            
            # Analyze usage patterns
            usage_by_type = {"avatar": 0, "banner": 0, "theme": 0}
            most_used_assets = {}
            daily_changes = {}
            
            for usage in usage_history:
                asset_type = usage.get("asset_type")
                asset_id = usage.get("asset_id")
                
                if asset_type in usage_by_type:
                    usage_by_type[asset_type] += 1
                
                most_used_assets[asset_id] = most_used_assets.get(asset_id, 0) + 1
                
                day_key = usage.get("created_at").strftime("%Y-%m-%d") if usage.get("created_at") else "unknown"
                daily_changes[day_key] = daily_changes.get(day_key, 0) + 1
            
            # Current active assets
            active_assets = {
                "avatar": next((a for a in current_assets if a.get("item_type") == "avatar" and a.get("currently_active")), None),
                "banner": next((a for a in current_assets if a.get("item_type") == "banner" and a.get("currently_active")), None),
                "theme": next((a for a in current_assets if a.get("item_type") == "theme" and a.get("currently_active")), None)
            }
            
            usage_tracking = {
                "user_id": target_user_id,
                "period": "last_30_days",
                "current_active_assets": active_assets,
                "usage_statistics": {
                    "total_changes": len(usage_history),
                    "changes_by_type": usage_by_type,
                    "average_daily_changes": len(usage_history) / 30,
                    "most_active_day": max(daily_changes.items(), key=lambda x: x[1])[0] if daily_changes else None
                },
                "asset_preferences": {
                    "most_used_asset": max(most_used_assets.items(), key=lambda x: x[1])[0] if most_used_assets else None,
                    "preferred_type": max(usage_by_type.items(), key=lambda x: x[1])[0] if usage_by_type else None,
                    "change_frequency": "high" if len(usage_history) > 20 else "moderate" if len(usage_history) > 5 else "low"
                },
                "recommendations": [
                    "Consider purchasing frequently used rented items to save SBD tokens",
                    "Explore new asset types to diversify your profile appearance",
                    "Set up asset rotation schedules for variety"
                ],
                "generated_at": datetime.utcnow().isoformat()
            }
            
            logger.info("Provided asset usage resource for user %s (%d usage records)", 
                       target_user_id, len(usage_history))
            
            return json.dumps(usage_tracking, indent=2, default=str)
            
        except Exception as e:
            logger.error("Failed to get asset usage resource for %s: %s", user_id, e)
            return json.dumps({"error": f"Failed to retrieve asset usage: {str(e)}"}, indent=2)

        else:
        logger.warning("FastMCP not available - shop and asset resources will not be registered")