# 8.2 CORS Configuration

## Overview

The Second Brain Database implements comprehensive Cross-Origin Resource Sharing (CORS) configuration to securely handle cross-origin requests from web applications while preventing unauthorized access. CORS is configured at multiple levels with different policies for different endpoint types.

## Technical Architecture

### Multi-Level CORS Implementation

CORS is implemented through three distinct layers:

1. **Global API CORS** - Applied to all FastAPI routes
2. **Documentation CORS** - Specific configuration for `/docs`, `/redoc`, `/openapi.json`
3. **MCP Server CORS** - Optional CORS for Model Context Protocol HTTP transport

### Configuration Sources

```python
# Global CORS configuration in main.py
cors_origins = [
    "http://localhost:3000",  # Local development
    "http://localhost:8000",  # Same origin
    "https://agentchat.vercel.app",  # AgentChat UI hosted version
]

# Additional origins from environment
if hasattr(settings, "CORS_ORIGINS") and settings.CORS_ORIGINS:
    additional_origins = [origin.strip() for origin in settings.CORS_ORIGINS.split(",")]
    cors_origins.extend(additional_origins)

app.add_middleware(
    CORSMiddleware,
    allow_origins=cors_origins,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"],
    allow_headers=["*"],
    expose_headers=["*"],
    max_age=3600,
)
```

## Security Features

### Origin Validation

#### Production Mode
```python
# Documentation CORS - Production
if settings.is_production:
    origins = []
    if settings.DOCS_CORS_ORIGINS:
        origins = [origin.strip() for origin in settings.DOCS_CORS_ORIGINS.split(",")]
    elif settings.BASE_URL:
        origins = [settings.BASE_URL]

    return {
        "allow_origins": origins,
        "allow_credentials": settings.DOCS_CORS_CREDENTIALS,
        "allow_methods": settings.DOCS_CORS_METHODS.split(","),
        "allow_headers": settings.DOCS_CORS_HEADERS.split(","),
        "max_age": settings.DOCS_CORS_MAX_AGE,
    }
```

#### Development Mode
```python
# Documentation CORS - Development
return {
    "allow_origins": ["*"],
    "allow_credentials": True,
    "allow_methods": ["GET", "POST", "PUT", "DELETE"],
    "allow_headers": ["*"],
    "max_age": 86400,
}
```

### Preflight Request Handling

CORS preflight requests (OPTIONS method) are automatically handled by Starlette's CORSMiddleware:

- **Preflight Caching**: `max_age=3600` (1 hour) reduces preflight requests
- **Method Validation**: Only allowed HTTP methods are permitted
- **Header Validation**: Request headers are validated against allowlist

### Credential Support

```python
# Global API CORS
allow_credentials=True,  # Allows cookies, authorization headers
allow_headers=["*"],     # Allows all headers
expose_headers=["*"],    # Exposes all response headers
```

## Performance Characteristics

### Preflight Optimization

- **Preflight Caching**: 1-hour cache duration reduces redundant OPTIONS requests
- **Minimal Overhead**: CORS headers add negligible processing time (< 1ms)
- **Conditional Processing**: CORS logic only executes for cross-origin requests

### Memory Usage

- **Origin Lists**: Stored in memory as simple string lists
- **No Database Queries**: CORS validation doesn't require database access
- **Static Configuration**: CORS settings loaded once at startup

## Testing Strategy

### CORS Validation Tests

```python
def test_cors_headers():
    """Test CORS headers are present for cross-origin requests."""
    response = client.options(
        "/api/auth/login",
        headers={"Origin": "https://agentchat.vercel.app"}
    )

    assert response.status_code == 200
    assert "Access-Control-Allow-Origin" in response.headers
    assert "Access-Control-Allow-Credentials" in response.headers
    assert response.headers["Access-Control-Allow-Origin"] == "https://agentchat.vercel.app"

def test_cors_preflight():
    """Test CORS preflight request handling."""
    response = client.options(
        "/api/auth/login",
        headers={
            "Origin": "https://agentchat.vercel.app",
            "Access-Control-Request-Method": "POST",
            "Access-Control-Request-Headers": "Content-Type,Authorization"
        }
    )

    assert response.status_code == 200
    assert response.headers["Access-Control-Allow-Methods"] == "GET,POST,PUT,DELETE,OPTIONS,PATCH"
    assert "Content-Type" in response.headers["Access-Control-Allow-Headers"]
```

### Origin Validation Tests

```python
def test_allowed_origins():
    """Test only configured origins are allowed."""
    allowed_origins = ["https://agentchat.vercel.app", "http://localhost:3000"]

    for origin in allowed_origins:
        response = client.get("/api/health", headers={"Origin": origin})
        assert response.headers["Access-Control-Allow-Origin"] == origin

def test_blocked_origins():
    """Test unauthorized origins are blocked."""
    response = client.get("/api/health", headers={"Origin": "https://malicious-site.com"})
    assert "Access-Control-Allow-Origin" not in response.headers
```

### Documentation CORS Tests

```python
def test_docs_cors_production():
    """Test documentation CORS in production mode."""
    with override_settings(is_production=True):
        response = client.get("/docs", headers={"Origin": settings.BASE_URL})
        assert response.headers["Access-Control-Allow-Origin"] == settings.BASE_URL

def test_docs_cors_development():
    """Test documentation CORS in development mode."""
    with override_settings(DEBUG=True):
        response = client.get("/docs", headers={"Origin": "http://localhost:3000"})
        assert response.headers["Access-Control-Allow-Origin"] == "http://localhost:3000"
```

## Configuration

### Environment Variables

```bash
# Global CORS configuration
CORS_ORIGINS="https://myapp.com,https://staging.myapp.com"

# Documentation CORS (production)
DOCS_CORS_ORIGINS="https://internal.mycompany.com"
DOCS_CORS_CREDENTIALS=false
DOCS_CORS_METHODS="GET"
DOCS_CORS_HEADERS="Content-Type,Authorization"
DOCS_CORS_MAX_AGE=3600

# MCP Server CORS
MCP_CORS_ENABLED=true
MCP_ALLOWED_ORIGINS="https://mcp-client.myapp.com"
```

### Configuration File (.sbd)

```ini
# CORS Configuration
CORS_ORIGINS=https://myapp.com,https://staging.myapp.com

# Documentation CORS
DOCS_CORS_ORIGINS=https://internal.mycompany.com
DOCS_CORS_CREDENTIALS=false
DOCS_CORS_METHODS=GET
DOCS_CORS_HEADERS=Content-Type,Authorization
DOCS_CORS_MAX_AGE=3600

# MCP CORS
MCP_CORS_ENABLED=true
MCP_ALLOWED_ORIGINS=https://mcp-client.myapp.com
```

## Practical Examples

### CORS Response Headers

#### Successful CORS Request
```http
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://agentchat.vercel.app
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: *
Content-Type: application/json
```

#### Preflight Request Response
```http
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://agentchat.vercel.app
Access-Control-Allow-Methods: GET,POST,PUT,DELETE,OPTIONS,PATCH
Access-Control-Allow-Headers: Content-Type,Authorization,X-Requested-With
Access-Control-Max-Age: 3600
```

### Origin Validation Logic

```python
def validate_cors_origin(origin: str, allowed_origins: List[str]) -> bool:
    """Validate if origin is allowed for CORS."""
    if not origin:
        return False

    # Exact match
    if origin in allowed_origins:
        return True

    # Wildcard matching (future enhancement)
    for allowed in allowed_origins:
        if allowed == "*":
            return True
        # Domain matching logic could be added here

    return False
```

### Dynamic Origin Management

```python
def add_cors_origin(new_origin: str):
    """Dynamically add allowed CORS origin."""
    if new_origin not in settings.CORS_ORIGINS_LIST:
        settings.CORS_ORIGINS_LIST.append(new_origin)
        # Update middleware configuration
        update_cors_middleware()

def update_cors_middleware():
    """Update CORS middleware with new configuration."""
    # This would require recreating the CORSMiddleware
    # In practice, this might require application restart
    pass
```

## Security Analysis

### CSRF Protection

CORS provides additional protection against CSRF attacks:

- **Origin Validation**: Ensures requests come from allowed domains
- **Credential Restrictions**: Limits when credentials are sent
- **Preflight Requirements**: Complex requests require preflight validation

### Attack Mitigation

1. **Cross-Origin Attacks**
   - Origin validation prevents unauthorized cross-origin requests
   - Credential restrictions limit cookie/header exposure

2. **Preflight Bypass Attempts**
   - Strict preflight validation for complex requests
   - Method and header whitelisting

3. **Header Injection**
   - CORS headers are set programmatically, not from user input
   - Prevents header injection through CORS responses

### Security Considerations

- **Wildcard Origins**: Avoid `allow_origins=["*"]` with `allow_credentials=True`
- **Header Exposure**: Be selective with `expose_headers` in production
- **Preflight Caching**: Balance security with performance (max_age setting)

## Monitoring and Alerting

### CORS Violation Monitoring

```python
def monitor_cors_violations():
    """Monitor and alert on CORS policy violations."""
    # Check for blocked origins
    blocked_requests = get_blocked_cors_requests()

    if len(blocked_requests) > 10:  # Threshold
        alert_security_team(f"High CORS violation rate: {len(blocked_requests)} blocked requests")

    # Log suspicious patterns
    for request in blocked_requests:
        if is_suspicious_origin(request.origin):
            log_security_event("suspicious_cors_attempt", ip=request.ip, origin=request.origin)
```

### Performance Monitoring

```python
def monitor_cors_performance():
    """Monitor CORS-related performance metrics."""
    preflight_count = get_preflight_request_count()
    cors_processing_time = measure_cors_processing_time()

    if cors_processing_time > 0.005:  # 5ms threshold
        log_performance_issue("CORS processing slow", processing_time=cors_processing_time)

    # Monitor preflight ratio
    total_requests = get_total_request_count()
    preflight_ratio = preflight_count / total_requests if total_requests > 0 else 0

    if preflight_ratio > 0.1:  # 10% preflight ratio
        log_performance_issue("High preflight request ratio", ratio=preflight_ratio)
```

## Troubleshooting

### Common Issues

1. **CORS Errors in Browser**
   ```javascript
   // Browser console error
   Access to XMLHttpRequest at 'https://api.example.com/auth/login'
   from origin 'https://app.example.com' has been blocked by CORS policy

   // Solution: Add origin to CORS_ORIGINS configuration
   CORS_ORIGINS="https://app.example.com"
   ```

2. **Preflight Request Failures**
   ```http
   // Request
   OPTIONS /api/users HTTP/1.1
   Origin: https://app.example.com
   Access-Control-Request-Method: DELETE

   // Response - Method not allowed
   HTTP/1.1 403 Forbidden

   // Solution: Add DELETE to allowed methods
   allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"]
   ```

3. **Credentials Not Sent**
   ```javascript
   // Frontend code
   fetch('/api/auth/login', {
     method: 'POST',
     credentials: 'include',  // Requires CORS allow_credentials=True
     // ...
   })

   // Solution: Ensure allow_credentials=True in CORS config
   ```

### Debug Configuration

```python
# Development CORS settings (more permissive)
if settings.DEBUG:
    cors_config = {
        "allow_origins": ["*"],
        "allow_credentials": True,
        "allow_methods": ["*"],
        "allow_headers": ["*"],
        "max_age": 86400,  # Longer cache for development
    }
```

### Testing CORS Locally

```bash
# Test CORS headers
curl -H "Origin: http://localhost:3000" \
     -H "Access-Control-Request-Method: POST" \
     -X OPTIONS \
     http://localhost:8000/api/auth/login

# Check response headers
# Should include: Access-Control-Allow-Origin, Access-Control-Allow-Methods, etc.
```

## Best Practices

### Production Configuration

1. **Specific Origins**: Use specific domains instead of wildcards
   ```python
   # Good
   allow_origins=["https://myapp.com", "https://admin.myapp.com"]

   # Avoid
   allow_origins=["*"]  # Especially with allow_credentials=True
   ```

2. **Minimal Headers**: Only expose necessary headers
   ```python
   # Good
   allow_headers=["Content-Type", "Authorization", "X-Requested-With"]
   expose_headers=["X-RateLimit-Remaining", "X-RateLimit-Reset"]

   # Avoid
   allow_headers=["*"]  # Too permissive
   expose_headers=["*"]  # Exposes internal headers
   ```

3. **Credential Security**: Be cautious with credentials
   ```python
   # Only enable credentials for trusted origins
   allow_credentials=True  # Only when necessary
   ```

### Development vs Production

```python
# Development - Permissive for ease of development
cors_origins = ["http://localhost:*", "http://127.0.0.1:*"]
allow_credentials = True
max_age = 86400  # Longer cache

# Production - Restrictive for security
cors_origins = ["https://myapp.com", "https://api.myapp.com"]
allow_credentials = False  # Use JWT tokens instead
max_age = 3600  # Standard cache
```

## Conclusion

The CORS configuration provides secure cross-origin resource sharing with flexible configuration for different environments. The multi-layered approach ensures appropriate security controls while maintaining usability for legitimate cross-origin requests.

**Key Benefits:**
- Secure cross-origin request handling
- Environment-specific configuration
- Performance-optimized preflight caching
- Comprehensive security monitoring
- Easy configuration management</content>
<parameter name="filePath">/Users/rohan/Documents/repos/second_brain_database/docs/8.2.md